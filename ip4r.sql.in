-- Create the user-defined types for IP4 and IP4 intervals (ip4 ip4r)
-- 

-- Adjust this setting to control where the objects get created.
SET search_path = public;

BEGIN;

CREATE OR REPLACE FUNCTION ip4_in(cstring)
RETURNS ip4
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4_out(ip4)
RETURNS cstring
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE TYPE ip4 (
	INTERNALLENGTH = 4,
	INPUT = ip4_in,
	OUTPUT = ip4_out,
	ALIGNMENT = int4,
	PASSEDBYVALUE
);

COMMENT ON TYPE ip4 IS
'IPv4 address ''#.#.#.#''';

COMMIT;

CREATE OR REPLACE FUNCTION ip4(inet)
RETURNS ip4
AS 'MODULE_PATHNAME', 'ip4_cast_from_inet'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION cidr(ip4)
RETURNS cidr
AS 'MODULE_PATHNAME', 'ip4_cast_to_cidr'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4(text)
RETURNS ip4
AS 'MODULE_PATHNAME', 'ip4_cast_from_text'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION text(ip4)
RETURNS text
AS 'MODULE_PATHNAME', 'ip4_cast_to_text'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION to_bigint(ip4)
RETURNS bigint
AS 'MODULE_PATHNAME', 'ip4_cast_to_bigint'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4(bigint)
RETURNS ip4
AS 'MODULE_PATHNAME', 'ip4_cast_from_bigint'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION to_double(ip4)
RETURNS double precision
AS 'MODULE_PATHNAME', 'ip4_cast_to_double'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4(double precision)
RETURNS ip4
AS 'MODULE_PATHNAME', 'ip4_cast_from_double'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE CAST (text as ip4) WITH FUNCTION ip4(text);
CREATE CAST (inet as ip4) WITH FUNCTION ip4(inet) AS ASSIGNMENT;
CREATE CAST (ip4 as cidr) WITH FUNCTION cidr(ip4) AS ASSIGNMENT;
CREATE CAST (ip4 as text) WITH FUNCTION text(ip4);

CREATE CAST (ip4 as bigint) WITH FUNCTION to_bigint(ip4);
CREATE CAST (bigint as ip4) WITH FUNCTION ip4(bigint);

CREATE CAST (ip4 as double precision) WITH FUNCTION to_double(ip4);
CREATE CAST (double precision as ip4) WITH FUNCTION ip4(double precision);

--

BEGIN;

CREATE OR REPLACE FUNCTION ip4r_in(cstring)
RETURNS ip4r
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_out(ip4r)
RETURNS cstring
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE TYPE ip4r (
	INTERNALLENGTH = 8,
	INPUT = ip4r_in,
	OUTPUT = ip4r_out,
	ALIGNMENT = int4,
        ELEMENT = ip4
);

COMMENT ON TYPE ip4r IS
'IPv4 range ''#.#.#.#-#.#.#.#'' or ''#.#.#.#/#'' or ''#.#.#.#''';

COMMIT;

CREATE OR REPLACE FUNCTION ip4r(cidr)
RETURNS ip4r
AS 'MODULE_PATHNAME', 'ip4r_cast_from_cidr'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r(text)
RETURNS ip4r
AS 'MODULE_PATHNAME', 'ip4r_cast_from_text'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r(ip4)
RETURNS ip4r
AS 'MODULE_PATHNAME', 'ip4r_cast_from_ip4'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION text(ip4r)
RETURNS text
AS 'MODULE_PATHNAME', 'ip4r_cast_to_text'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION cidr(ip4r)
RETURNS cidr
AS 'MODULE_PATHNAME', 'ip4r_cast_to_cidr'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r(ip4,ip4)
RETURNS ip4r
AS 'MODULE_PATHNAME', 'ip4r_from_ip4s'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE CAST (text as ip4r) WITH FUNCTION ip4r(text);
CREATE CAST (cidr as ip4r) WITH FUNCTION ip4r(cidr) AS ASSIGNMENT;
CREATE CAST (ip4r as cidr) WITH FUNCTION cidr(ip4r);
CREATE CAST (ip4 as ip4r) WITH FUNCTION ip4r(ip4) AS IMPLICIT;
CREATE CAST (ip4r as text) WITH FUNCTION text(ip4r);

CREATE OR REPLACE FUNCTION is_cidr(ip4r)
RETURNS boolean
AS 'MODULE_PATHNAME', 'ip4r_is_cidr'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION lower(ip4r)
RETURNS ip4
AS 'MODULE_PATHNAME', 'ip4r_lower'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION upper(ip4r)
RETURNS ip4
AS 'MODULE_PATHNAME', 'ip4r_upper'
LANGUAGE 'C' IMMUTABLE STRICT;

-- Comparison methods for ip4

CREATE OR REPLACE FUNCTION ip4_cmp(ip4, ip4)
RETURNS integer
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4_lt(ip4, ip4)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4_gt(ip4, ip4)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4_eq(ip4, ip4)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4_neq(ip4, ip4)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4_le(ip4, ip4)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4_ge(ip4, ip4)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

-- Comparison methods for ip4r

CREATE OR REPLACE FUNCTION ip4r_cmp(ip4r, ip4r)
RETURNS integer
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_lt(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_gt(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_eq(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_neq(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_le(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_ge(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_overlaps(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_contains(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_contains_strict(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_contained_by(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_contained_by_strict(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

-- overlap relations (mainly for rtree)

CREATE OR REPLACE FUNCTION ip4r_left_of(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_left_overlap(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_right_of(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_right_overlap(ip4r, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

-- mixed ip4/ip4r

CREATE OR REPLACE FUNCTION ip4_contains(ip4r, ip4)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4_contained_by(ip4, ip4r)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

-- misc funcs

CREATE OR REPLACE FUNCTION ip4r_union(ip4r, ip4r)
RETURNS ip4r
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_inter(ip4r, ip4r)
RETURNS ip4r
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION ip4r_size(ip4r)
RETURNS double precision
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

--
-- OPERATORS for ip4 only
--

CREATE OPERATOR < (
	LEFTARG = ip4,
	RIGHTARG = ip4,
	PROCEDURE = ip4_lt,
	COMMUTATOR = '>',
	NEGATOR = '>=',
	RESTRICT = scalarltsel,
	JOIN = scalarltjoinsel
);

CREATE OPERATOR <= (
	LEFTARG = ip4,
	RIGHTARG = ip4,
	PROCEDURE = ip4_le,
	COMMUTATOR = '>=',
	NEGATOR = '>',
	RESTRICT = scalarltsel,
	JOIN = scalarltjoinsel
);

CREATE OPERATOR > (
	LEFTARG = ip4,
	RIGHTARG = ip4,
	PROCEDURE = ip4_gt,
	COMMUTATOR = '<',
	NEGATOR = '<=',
	RESTRICT = scalargtsel,
	JOIN = scalargtjoinsel
);

CREATE OPERATOR >= (
	LEFTARG = ip4,
	RIGHTARG = ip4,
	PROCEDURE = ip4_ge,
	COMMUTATOR = '<=',
	NEGATOR = '<',
	RESTRICT = scalargtsel,
	JOIN = scalargtjoinsel
);

CREATE OPERATOR = (
	LEFTARG = ip4,
	RIGHTARG = ip4,
	PROCEDURE = ip4_eq,
	COMMUTATOR = '=',
	NEGATOR = '<>',
	RESTRICT = eqsel,
	JOIN = eqjoinsel,
	SORT1 = '<',
	SORT2 = '<'
);

CREATE OPERATOR <> (
	LEFTARG = ip4,
	RIGHTARG = ip4,
	PROCEDURE = ip4_neq,
	COMMUTATOR = '<>',
	NEGATOR = '=',
	RESTRICT = neqsel,
	JOIN = neqjoinsel
);


--
-- OPERATORS for ip4r only
--

CREATE OPERATOR < (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_lt,
	COMMUTATOR = '>',
	NEGATOR = '>=',
	RESTRICT = scalarltsel,
	JOIN = scalarltjoinsel
);

CREATE OPERATOR <= (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_le,
	COMMUTATOR = '>=',
	NEGATOR = '>',
	RESTRICT = scalarltsel,
	JOIN = scalarltjoinsel
);

CREATE OPERATOR > (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_gt,
	COMMUTATOR = '<',
	NEGATOR = '<=',
	RESTRICT = scalargtsel,
	JOIN = scalargtjoinsel
);

CREATE OPERATOR >= (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_ge,
	COMMUTATOR = '<=',
	NEGATOR = '<',
	RESTRICT = scalargtsel,
	JOIN = scalargtjoinsel
);

CREATE OPERATOR << (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_contained_by_strict,
	COMMUTATOR = '>>',
	RESTRICT = contsel,
	JOIN = contjoinsel
);

CREATE OPERATOR <<= (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_contained_by,
	COMMUTATOR = '>>=',
	RESTRICT = contsel,
	JOIN = contjoinsel
);

CREATE OPERATOR && (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_overlaps,
	COMMUTATOR = '&&',
	RESTRICT = areasel,
	JOIN = areajoinsel
);

CREATE OPERATOR >> (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_contains_strict,
	COMMUTATOR = '<<',
	RESTRICT = contsel,
	JOIN = contjoinsel
);

CREATE OPERATOR >>= (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_contains,
	COMMUTATOR = '<<=',
	RESTRICT = contsel,
	JOIN = contjoinsel
);

CREATE OPERATOR = (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_eq,
	COMMUTATOR = '=',
	NEGATOR = '<>',
	RESTRICT = eqsel,
	JOIN = eqjoinsel,
	SORT1 = '<',
	SORT2 = '<'
);

CREATE OPERATOR <> (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_neq,
	COMMUTATOR = '<>',
	NEGATOR = '=',
	RESTRICT = neqsel,
	JOIN = neqjoinsel
);

-- an attempt at compatibility with ipr only (not recommended for new code)

CREATE OPERATOR @ (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_contains,
	COMMUTATOR = '~',
	RESTRICT = contsel,
	JOIN = contjoinsel
);

CREATE OPERATOR ~ (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_contained_by,
	COMMUTATOR = '@',
	RESTRICT = contsel,
	JOIN = contjoinsel
);

-- relationals for rtree

CREATE OPERATOR <<< (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_left_of,
	COMMUTATOR = '>>>',
	RESTRICT = positionsel,
	JOIN = positionjoinsel
);

CREATE OPERATOR >>> (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_right_of,
	COMMUTATOR = '<<<',
	RESTRICT = positionsel,
	JOIN = positionjoinsel
);

-- These next two look like they should be commutators, but they
-- are _NOT_.

CREATE OPERATOR &<< (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_left_overlap,
	RESTRICT = positionsel,
	JOIN = positionjoinsel
);

CREATE OPERATOR &>> (
	LEFTARG = ip4r,
	RIGHTARG = ip4r,
	PROCEDURE = ip4r_right_overlap,
	RESTRICT = positionsel,
	JOIN = positionjoinsel
);

--
-- OPERATORS for ip4 and ip4r together
--
-- these seem to do more harm than good.
--CREATE OPERATOR <<= (
--	LEFTARG = ip4,
--	RIGHTARG = ip4r,
--	PROCEDURE = ip4_contained_by,
--	COMMUTATOR = '>>=',
--	RESTRICT = contsel,
--	JOIN = contjoinsel
--);
--
--CREATE OPERATOR >>= (
--	LEFTARG = ip4r,
--	RIGHTARG = ip4,
--	PROCEDURE = ip4_contains,
--	COMMUTATOR = '<<=',
--	RESTRICT = contsel,
--	JOIN = contjoinsel
--);
--

-- rtree support methods

-- union and inter actually take ip4r parameters, but we must
-- declare them as taking "internal" to maintain the security of
-- the internal type. (functions returning internal must take at
-- least one parameter of internal type). union could be declared
-- to return an ip4r, but inter can return a NULL pointer due to
-- some very dubious calling conventions in the backend.

CREATE OR REPLACE FUNCTION rt_ip4r_union(internal,internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION rt_ip4r_inter(internal,internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION rt_ip4r_size(ip4r,internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

-- define the GiST support methods

CREATE OR REPLACE FUNCTION gip4r_consistent(internal,ip4r,int4)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gip4r_compress(internal)
RETURNS internal 
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gip4r_decompress(internal)
RETURNS internal 
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gip4r_penalty(internal,internal,internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE 'C' STRICT;

CREATE OR REPLACE FUNCTION gip4r_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gip4r_union(internal, internal)
RETURNS ip4r
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gip4r_same(ip4r, ip4r, internal)
RETURNS internal 
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

-- Create the operator classes for indexing

CREATE OPERATOR CLASS btree_ip4_ops
DEFAULT FOR TYPE ip4 USING btree
AS
	OPERATOR	1	< ,
	OPERATOR	2	<= ,
	OPERATOR	3	= ,
	OPERATOR	4	>= ,
	OPERATOR	5	> ,
	FUNCTION	1	ip4_cmp(ip4, ip4);

CREATE OPERATOR CLASS btree_ip4r_ops
DEFAULT FOR TYPE ip4r USING btree
AS
	OPERATOR	1	< ,
	OPERATOR	2	<= ,
	OPERATOR	3	= ,
	OPERATOR	4	>= ,
	OPERATOR	5	> ,
	FUNCTION	1	ip4r_cmp(ip4r, ip4r);

CREATE OPERATOR CLASS rtree_ip4r_ops
DEFAULT FOR TYPE ip4r USING rtree
AS
	OPERATOR	1	<<< ,
	OPERATOR	2	&<< ,
	OPERATOR	3	&& ,
	OPERATOR	4	&>> ,
	OPERATOR	5	>>> ,
	OPERATOR	6	= ,
	OPERATOR	7	<<= ,
	OPERATOR	8	>>= ,
	FUNCTION	1	rt_ip4r_union(internal, internal),
	FUNCTION	2	rt_ip4r_inter(internal, internal),
	FUNCTION	3	rt_ip4r_size(ip4r, internal);

CREATE OPERATOR CLASS gist_ip4r_ops
DEFAULT FOR TYPE ip4r USING gist 
AS
	OPERATOR	1	>>= ,
	OPERATOR	2	<<= ,
	OPERATOR	3	>> ,
	OPERATOR	4	<< ,
	OPERATOR	5	&& ,
	OPERATOR	6	= ,
	FUNCTION	1	gip4r_consistent (internal, ip4r, int4),
	FUNCTION	2	gip4r_union (internal, internal),
	FUNCTION	3	gip4r_compress (internal),
	FUNCTION	4	gip4r_decompress (internal),
	FUNCTION	5	gip4r_penalty (internal, internal, internal),
	FUNCTION	6	gip4r_picksplit (internal, internal),
	FUNCTION	7	gip4r_same (ip4r, ip4r, internal);

-- end
